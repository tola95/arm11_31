
 /*
 *  Created on: 22 May 2014
 *      Author: Group 31
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stdint.h>

<<<<<<< HEAD
// This macro makes it easier to reference the PC, leading to prettier code.
#define PC state.reg[15]

const int NUMBER_OF_REGISTERS = 17; // Number of registers
const int memSize = 16384; // maximum number of instructions that can be stored.
uint32_t zero = 0;
=======
 //Since static const didn't work, this is an alternative 
//which is safer than just writing the number.
enum {REG = 17, MEM = 65536};

/*typedef only gives name to the struct ARM_STATE so that 
you don't have to right struct ARM_STATE when you initialise
the struct. This leads you to only have to write State when 
initialising*/

//creating struct for each register.
typedef struct ARM_REGISTER {
  char ident[4];
  uint32_t reg;
} Register;

//Creating a pointer to the ARM Machine main memory.
uint8_t *memPtr;

//This method is called by the main method to initialise all the memory.
void initMem() {
  uint8_t *memory = (uint8_t *) calloc(MEM, 1);
  memPtr = memory;
} 

//Initialised registers to 0 and assigned each
//register to its string name.
Register ARMReg[REG] = {
  {"$0", 0},
  {"$1", 0},
  {"$2", 0},
  {"$3", 0},
  {"$4", 0},
  {"$5", 0},
  {"$6", 0},
  {"$7", 0},
  {"$8", 0},
  {"$9", 0},
  {"$10", 0},
  {"$11", 0},
  {"$12", 0},
  {"SP", 0},
  {"LR", 0},
  {"PC", 0},
  {"CPSR", 0}
};

void printBits1(uint32_t x) { 
  int i;
  uint32_t mask = 1 << 31;
  for(i=0; i<32; ++i) { 
    if((x & mask) == 0)
      printf("0"); 
    else
      printf("1"); x = x << 1;
  }
  printf("\n "); }

//Data Processing instruction opcodes.
void and(uint32_t rn, uint32_t op2, uint32_t des) {
  ARMReg[des].reg = ARMReg[rn].reg & op2;
}

void eor(uint32_t rn, uint32_t op2, uint32_t des) {
  ARMReg[des].reg = ARMReg[rn].reg ^ op2;
}

void sub(uint32_t rn, uint32_t op2, uint32_t des) {
  uint32_t one = 1;
  ARMReg[des].reg = ARMReg[rn].reg + (~op2 + one);
}

void rsb(uint32_t rn, uint32_t op2, uint32_t des) {
  sub(op2, rn, des);
}

void add(uint32_t rn, uint32_t op2, uint32_t des) {
  ARMReg[des].reg = ARMReg[rn].reg + op2;
}

uint32_t tst(uint32_t rn, uint32_t op2) {
  uint32_t result = ARMReg[rn].reg & op2;
  return result;
}

uint32_t teq(uint32_t rn, uint32_t op2) {
  uint32_t result = ARMReg[rn].reg ^ op2;
  return result;
} 

uint32_t cmp(uint32_t rn, uint32_t op2) {
  uint32_t one = 1;
  uint32_t result = ARMReg[rn].reg + (~op2 + one);
  return result;
}

void orr(uint32_t rn, uint32_t op2, uint32_t des) {
  ARMReg[des].reg = ARMReg[rn].reg | op2;
}

void mov(uint32_t op2, uint32_t des) {
  ARMReg[des].reg = op2;
}

//This function chooses which the right operation depending on the opcode
void operateOp(uint32_t opcode, uint32_t rn, uint32_t op2, uint32_t des) {
  switch(opcode) {
    case 0x00000000 : and(rn, op2, des);
    break;
    case 0x00000001 : eor(rn, op2, des);
    break;
    case 0x00000002 : sub(rn, op2, des);
    break;
    case 0x00000003 : rsb(rn, op2, des);
    break;
    case 0x00000004 : add(rn, op2, des);
    break;
    case 0x00000008 : tst(rn, op2);
    break;
    case 0x00000009 : teq(rn, op2);
    break;
    case 0x0000000a : cmp(rn, op2);
    break;
    case 0x0000000c : orr(rn, op2, des);
    break;
    case 0x0000000d : mov(op2, des);
  }
}
>>>>>>> origin/master

//Creates a mask given the first and last index.
uint32_t masking(uint32_t inst, int left, int right) {
  int m = ((left - right) + 1);
  uint32_t result = ~(~0 << m) << right;
  inst &= result;
  inst >>= right;
  return inst;
}

<<<<<<< HEAD
// Struct representing the state of machine
  struct arm_State {
 	uint32_t reg[17];
	uint32_t memory[16384];	
 }  ;
=======
//Opcode and operation for when operand2 is not an immediate constant.
uint32_t lsl(uint32_t rm, uint32_t shift) {
  return rm << shift;
}
>>>>>>> origin/master

uint32_t lsr(uint32_t rm, uint32_t shift) {
  return rm >> shift;
}

// enumeration of all operation mnemonics for help with decoding and execution.
 enum mnemonic {  AND, EOR, SUB,
                  RSB, ADD, TST,
                  TEQ, CMP, ORR,
                  MOV, MUL, MLA,
                  LDR, STR, BEQ,
                  BNE, BGE, BLT,
                  BGT, BLE, B,
                  LSL, ANDEQ };

// Struct representing decoded instruction.
    struct decodedInstruction {
        enum mnemonic operation;
        uint32_t rd;
        uint32_t rn;
        uint32_t rm;
        uint32_t op2;
        int pending;
    } ;

// Struct representing fetched instruction.
    struct fetchedInstruction {
        uint32_t binaryInstruction;
        int pending;
    } ;

<<<<<<< HEAD
                  
// Helper method to write to register
 void putinreg(struct arm_State state, uint32_t rd, uint32_t op2) {
 	state.reg[rd] = op2;	
 }
 
 void and(struct arm_State state, uint32_t rn, uint32_t op2, int r) {
 	state.reg[r] = rn & op2;
 }




 void eor(struct arm_State state, uint32_t rn, uint32_t op2, int r) {
 	state.reg[r] = rn ^ op2;
 }

 void sub(struct arm_State state, uint32_t rn, uint32_t op2, int r) {
 	state.reg[r] = rn - op2;
 }

 int *decToBinary(int i) {
	 int answer[32]; // 1
	 int *p;
	 int j = 0;
	 while (i>0) {
        answer[j] = i % 2 ; 
        i = floor(i/2);
        j++;
	 } 	
	 p = answer;
	 return p;
 } 

 void rsb(struct arm_State state, uint32_t rn, uint32_t op2, int r) {
 	state.reg[r] = op2 - rn;
 }


 void add(struct arm_State state, uint32_t rn, uint32_t op2, int r) {
 	state.reg[r] = rn + op2;
 }

 uint32_t tst(struct arm_State state, uint32_t rn, uint32_t op2) {
	 // As AND but result not written
	 return state.reg[rn] & op2;
 }


// Helper method to fetch from register
 uint32_t fetchfromreg(struct arm_State state, uint32_t rn) {
	return state.reg[rn];
 }

// Helper method for selecting bits
 uint32_t selectbits(uint32_t i, int first, int last) {
	uint32_t mask = 0;
	int count = first;

        // Create the 32 bit mask
	while (count>=last) {
		mask = mask + 1  * pow(2, count);
		count--;
	}
        
	// & operation to extract the required bits
	i &= mask;

	//Extract the bits by shift right by 'last' amount of bits
	i >>= last;

        return i;
 }

 uint32_t teq(struct arm_State state, uint32_t rn, uint32_t op2) {
	 // As EOR but result not written
	 return state.reg[rn] ^ op2;
 }

 uint32_t cmp(struct arm_State state, uint32_t rn,  uint32_t op2) {
	 // As SUB but result not written
 	 return state.reg[rn] - op2;
  }

 void orr(struct arm_State state, uint32_t rn, uint32_t op2, uint32_t rd) {
	 state.reg[rd] = rn | op2;
  }

 void mov(struct arm_State state, uint32_t op2, uint32_t rd) {
 	 // Move op2 to destination register
 	putinreg(state, rd, op2);
 }

 // Multiply Instructions

void multiply(struct arm_State state, uint32_t rs, uint32_t rm, uint32_t rd) {
	uint32_t arg1 = fetchfromreg(state, rm);
	uint32_t arg2 = fetchfromreg(state, rs);
	uint32_t result = arg1 * arg2 ; 
	putinreg(state, rd, result);
}



 

// Method to increment PC to next instruction address.
void incrementPC( struct arm_State state ){

    PC += 1;   // PC is a macro defined earlier
=======
 

//function to increment PC to next instruction address.
void incrementPC(){

    ARMReg[15].reg += 1;//PC is a macro defined earlier
>>>>>>> origin/master

}


<<<<<<< HEAD
// Method to fetch the instruction at the current instruction address stored in PC.
void fetchNextInstruction(struct arm_State state, struct fetchedInstruction fetched){
=======
//function to fetch the instruction at the current instruction address stored in PC.
void fetchNextInstruction(struct fetchedInstruction fetched){
>>>>>>> origin/master

    fetched.binaryInstruction = ARMReg[15].reg; //PC is a macro defined earlier.
    fetched.pending = 1;
    
}
 
<<<<<<< HEAD
// Method to execute decoded instructions then clear decoded instructions pending flag.
void execute(struct arm_State state, struct decodedInstruction decoded){
=======
//function to execute decoded instructions then clear decoded instructions pending flag.
void execute(struct decodedInstruction decoded){
>>>>>>> origin/master

    enum mnemonic op = decoded.operation;
    switch (op){
        case AND : and(decoded.rn, decoded.op2, decoded.rd);
        break;
        case EOR : eor(decoded.rn, decoded.op2, decoded.rd);
        break;
        case SUB : sub(decoded.rn, decoded.op2, decoded.rd);
        break;
        case RSB : rsb(decoded.rn, decoded.op2, decoded.rd);
        break;
        case ADD : add(decoded.rn, decoded.op2, decoded.rd);
        break;
        case TST : tst(decoded.rn, decoded.op2);
        break;
        case TEQ : teq(decoded.rn, decoded.op2);
        break;
        case CMP : cmp(decoded.rn, decoded.op2);
        break;
        case ORR : orr(decoded.rn, decoded.op2, decoded.rd);
        break;
        case MOV : mov(decoded.op2, decoded.rd);
        default:
        break;
  }
    
}



// Method to decoded a previously fetched instrcution.
void decode(struct fetchedInstruction fetched){
}



 // Main Method
 int main(int argc, char **argv) {

<<<<<<< HEAD
	// arm state initialised.
	struct arm_State ARM_State;


	// Initialise the registers to zero
	int i;
	// Initialise the registers to zero
	for (int i = 0; i < NUMBER_OF_REGISTERS; i++) {
		ARM_State.reg[i] = zero;
	}


	 /* initialise memory to 0 */
	 uint32_t zero = 0;

	 for (i = 0; i < memSize; i++ ){
		 ARM_State.memory[i] = zero;
	 }
=======
   initMem();
>>>>>>> origin/master

	 /* file loading */
	 FILE *file = fopen(argv[1], "rb");

	 if (file == NULL){
		 perror("Error: Could not open file.");
		 exit(EXIT_FAILURE);
	 }
     
     
     /* Calculate file size then from the size, the number of 32-bit instructions in the file */
     const int bytesPerInstruction = 4;
     fseek( file, 0, SEEK_END );
     int instructionsSize = ftell(file)/bytesPerInstruction;
     fseek( file, 0, SEEK_SET );

<<<<<<< HEAD
     // Load the binary data into the memory array.
	 fread(ARM_State.memory, bytesPerInstruction, instructionsSize, file );
=======
     //Load the binary data into the memory array.
	 fread(memPtr, bytesPerInstruction, instructionsSize, file );
>>>>>>> origin/master

	 /* file closing */
	 fclose(file);


	// just to make sure its working.
	 printf("%d \n", instructionsSize);

    // Pipeline execution of instructions.
    // Start with no instructions decoded and no instructions fetched.
    struct fetchedInstruction fetched;
    struct decodedInstruction decoded;
    fetched.pending = 0;
    decoded.pending = 0;    

    
    // main pipeline loop.
     while ( 1 ) {

	 }

    printf("\n");
	 i = 0;
	 for ( i = 0; i < NUMBER_OF_REGISTERS; i++ ) {

        if ( decoded.pending == 1 ) {

            execute(decoded);

        }

        if ( fetched.pending == 1 ) {

            decode(fetched);
            
        }

        if (ARMReg[15].reg <  MEM) {

            fetchNextInstruction(fetched);
        }


        incrementPC();

     
     }
     

	 return EXIT_SUCCESS;

 }


